// Иван Рощин, 199х
// Ianpo/zx-pk.ru, 2018

#include <stdio.h>
#include <malloc.h>

#define byte unsigned char    /* 1 байт.  */
#define word unsigned short     /* 2 байта. */

/* ==========================================================================
       Функция test_cat - проверка правильности каталога TR-DOS.

Вход:  cat - адрес каталога в памяти, tracks - максимальное количество треков
       на диске.

Выход: 2-байтное значение, где младший байт - код ошибки или 0, если нет
       ошибок, а старший байт для некоторых кодов ошибок - номер элемента
       каталога, при рассмотрении которого была обнаружена ошибка.
========================================================================== */

word test_cat (byte cat[0x900], byte tracks)
{
 byte files=0;      /* Общее количество файлов.          */
 byte del_files=0;  /* Количество удалённых файлов.      */
 byte element=0;    /* Номер текущего элемента каталога. */

 /* Проверка идентификационного кода TR-DOS. */
 if (cat[0x8E7]!=0x10) return (1);

 /* Первый байт служебного сектора должен быть равен 0. */
 if (cat[0x800]!=0) return (2);

 /* Тип дискеты должен быть числом в диапазоне 0x16-0x19. */
 if ((cat[0x8E3]<0x16)||(cat[0x8E3]>0x19)) return (3);

 /* Номер первого свободного сектора должен быть числом в диапазоне 0-15. */
 if (cat[0x8E1]>15) return (4);

 /* Подсчитываем общее количество файлов и количество удалённых файлов,
    одновременно проверяя, чтобы номер начального сектора каждого файла
    был числом в диапазоне 0-15. */

 while (cat[element*16]!=0)
 { /* Пока не обнаружим неиспользуемый элемент или не просмотрим весь каталог. */
  files++;
  if (cat[element*16]==1) del_files++;
  if (cat[element*16+0x0E]>15) return (5+(element<<8));
  element++;
 }

 /* Проверяем, правильно ли в служебном секторе указано количество файлов
    и количество удалённых файлов. */

 if (cat[0x8E4]!=files) return (6);
 if (cat[0x8F4]!=del_files) return (7);

 /* Если сейчас element=128, то просмотрен весь каталог, иначе остались
    неиспользуемые элементы, и надо проверить, чтобы все они были помечены
    как неиспользуемые. */

 while (element<128)
 {
  if (cat[element*16]!=0) return (8+(element<<8));
  element++;
 }

 if (files>0)
 {/* Файлы есть. */

  /* Первый файл должен начинаться с трека 1, сектора 0. */
  if ((cat[0x0F]!=1)||(cat[0x0E]!=0)) return (9);

  /* Дисковый адрес (т.е. начальный трек-сектор) каждого файла, начиная
     со второго, должен быть равен дисковому адресу предыдущего файла,
     увеличенному на количество секторов в предыдущем файле. */

  for (element=1;element<files;element++)
  {
   if ((cat[(element-1)*16+0x0E]+cat[(element-1)*16+0x0F]*16+cat[(element-1)*16+0x0D])!=
       (cat[element*16+0x0E]+cat[element*16+0x0F]*16)) return (10+(element<<8));
  }

  /* Указанный в служебном секторе дисковый адрес первого свободного сектора
     должен быть равен дисковому адресу последнего файла, увеличенному на
     количество секторов в последнем файле. */

  if ((cat[(files-1)*16+0x0E]+cat[(files-1)*16+0x0F]*16+cat[(files-1)*16+0x0D])!=
      (cat[0x8E1]+cat[0x8E2]*16)) return (11);
 }
 else
 {/* Файлов нет. */

  /* Указанный в служебном секторе дисковый адрес первого свободного сектора
     должен быть "трек 1, сектор 0". */
  if ((cat[0x8E2]!=1)||(cat[0x8E1]!=0)) return (12);
 }

 /* Количество занятых секторов диска, сложенное с количеством свободных
    секторов, указанным в служебном секторе, не должно быть больше, чем
    содержится секторов на указанном при вызове функции максимальном
    количестве треков. */

 /* Преобразование к типу long нужно, чтобы избежать возможного переполнения
    при сравнении (для этого разрядность long должна быть больше двух байтов). */

 if ((cat[0x8E1]+cat[0x8E2]*16+cat[0x8E5]+(((long)(cat[0x8E6]<<8))&0xFFFF)) >
    (tracks*16)) return (13);

 /* Все проверки успешно пройдены - делаем вывод, что ошибок нет. */

 return (0);
}

int main (int argc, char **argv)
{
	FILE * file;
	void * bufptr;


	if ( argc == 2 )
	{
		bufptr = (void *)malloc( 0x900 );
		if ( bufptr != NULL )
		{
			file = fopen( argv[1], "rb" );
			if ( file != NULL )
			{
				fread( bufptr, 0x900, 1, file );
				fclose( file );
				printf("%04X", test_cat( bufptr, 2*80 ) );
			}
			else
				printf( "Can't open file %s fo reading\r\n", argv[1] );
			free ( bufptr );
		}
		else
			printf( "Memory allocation error\r\n" );
	}
	else
		printf( "Usage:\r\ntest_cat TRDfile\r\n" );
}
